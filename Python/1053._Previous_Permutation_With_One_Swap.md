# 1. Two Sum

**<font color=green>难度: Easy</font>**

## 刷题内容

> 原题连接

* https://leetcode.com/problems/two-sum

> 内容描述

```
Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

> 思路 1
******- 时间复杂度: O(N^2)******- 空间复杂度: O(1)******

跟第31题next permutation类似

看一个permutation，比如

[1,9,4,6,7]


- 从末尾开始，找到increasing subsequence，467，因为467无论怎么调，都不可能有比它更小的，数也被自然的分成两部分(1,9) 和 （4,6,7)
- 下一步是找这个sequence里面第一个比前面部分，比9小的，7，也很容易理解，因为下一个必定是(1,7)打头
- 交换 9和7 ，变成 (1,7,4,6,9), （再把后面的部分reverse，得到后面部分可得到的最小的，这一部分在这道题就不需要做了，因为题目只允许一次swap）

这个时候，得到结果 17469

再看一个例子

[3,1,1,3]
分成 (3) 和(1,1,3)，但是我们肯定要将3和第一个1交换，因为3处于越左边就越大，因此就有了下面代码中的这一行
`while tmp_i > idx and nums[tmp_i] == nums[tmp_i-1]`

```python
from bisect import *

class Solution:
    def prevPermOpt1(self, nums: List[int]) -> List[int]:
        idx = 0
        for i in range(len(nums)-2, -1, -1):
            if nums[i] > nums[i+1]: # find first number which is larger than it's after number
                idx = i
                break
        for i in range(len(nums)-1, idx-1, -1):
            if nums[i] < nums[idx]:
                tmp_i = i
                while tmp_i > idx and nums[tmp_i] == nums[tmp_i-1]: # if same number exist, we want the left-most one
                    tmp_i -= 1
                nums[tmp_i], nums[idx] = nums[idx], nums[tmp_i]
                break
        return nums
```
